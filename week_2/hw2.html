<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Networked Life</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="networked-life">Networked Life</h1>



<h5 id="glen-choo-1000472">Glen Choo 1000472</h5>



<h5 id="loo-juin-1000546">Loo Juin 1000546</h5>



<h5 id="tan-hao-qin-1000521">Tan Hao Qin 1000521</h5>



<h4 id="exercise-1"><strong>Exercise 1</strong></h4>

<p><em>a</em> <br>
<img src="q1_graph.png" alt="" title=""></p>

<p><em>b</em> <br>
1 <script type="math/tex" id="MathJax-Element-144">\rightarrow</script> A <br>
Price charged: <script type="math/tex" id="MathJax-Element-145">\$2000</script> <br>
Payoff: <script type="math/tex" id="MathJax-Element-146">\$3000 - \$2000 = \$1000</script></p>

<p>2 <script type="math/tex" id="MathJax-Element-147">\rightarrow</script> B <br>
Price charged: <script type="math/tex" id="MathJax-Element-148">\$900</script> <br>
Payoff: <script type="math/tex" id="MathJax-Element-149">\$1200 - \$900 = \$300</script></p>

<h4 id="exercise-2-ebay-auction-exercise-22-in-book"><strong>Exercise 2</strong>. eBay auction (exercise 2.2 in book)</h4>

<h5 id="alice-lists-a-lamp-for-sale-on-ebay-via-auction-with-both-the-start-price-and-reserve-price-set-to-700-and-a-duration-of-5-days">Alice lists a lamp for sale on eBay via auction with both the start price and reserve price set to $7.00 and a duration of 5 days.</h5>



<h5 id="the-minimal-increment-is-025-and-the-following-events-happen-during-the-auction">The minimal increment is $0.25 and the following events happen during the auction:</h5>

<ul>
<li>Day 1 Bidder 1 uses a proxy agent, setting the maximum bid up to $11.00. </li>
<li>Day 2 Bidder 2 bids $9.25.</li>
<li>Day 3 Bidder 3 uses a proxy agent, setting the maximum bid up to $17.25. </li>
<li>Day 4 Bidder 2 bids $13.65.</li>
<li>Day 5 Bidder 1 bids $27.45.</li>
</ul>



<h5 id="list-the-bidding-history-of-all-three-bidders-over-each-day-of-the-auction-who-is-the-winner-and-what-price-does-she-pay">List the bidding history of all three bidders over each day of the auction. Who is the winner and what price does she pay?</h5>



<h4 id="day-1">Day 1</h4>

<p>Bidder 1 uses proxy agent. Agent bids $7.00 on Bidder 1’s behalf.</p>

<p>Ask price becomes $7.25</p>



<h4 id="day-2">Day 2</h4>

<p>Bidder 2 bids $9.25</p>

<p>Ask price becomes $7.50</p>

<p>Bidder 1’s agent bids $9.50 since it does not exceeded the maximum bid</p>

<p>Ask price becomes $9.75</p>



<h4 id="day-3">Day 3</h4>

<p>Bidder 3 starts agent. Bidder 1 and Bidder 3 agents outbid each other until Bidder 1 reaches maximum bid value. </p>

<p>Bidder 3 agent then bids $11.25</p>

<p>Ask price becomes $11.50</p>



<h4 id="day-4">Day 4</h4>

<p>Bidder 2 bids $13.65</p>

<p>Ask price becomes $11.75</p>

<p>Bidder 1’s agent bids $13.90 since it does not exceed the maximum bid</p>

<p>Ask price becomes $14.15</p>



<h4 id="day-5">Day 5</h4>

<p>Bidder 1 bids $27.45</p>

<p>Ask price becomes $14.40</p>

<p>Bidder 3’s agent keeps bidding until the ask price exceeds its maximum bid</p>

<p>Ask price becomes $17.40</p>



<h4 id="end">End</h4>

<p>Bidder 1 wins and pays $17.40</p>

<p><script type="math/tex; mode=display" id="MathJax-Element-162">\begin{array}{cccccc}\hline
&\text{Day 1}&\text{Day 2}&\text{Day 3}&\text{Day 4}&\text{Day 5}
\\\hline
\text{Bidder 1}&$7.00&$9.50&$11.00&$11.00&$27.45\\
\text{Bidder 2}&-&$9.25&$9.25&$13.65&$13.65\\
\text{Bidder 3}&-&-&$11.25&$13.90&$16.90\\
\text{Ask Price}&$7.25&$9.75&$11.50&$14.15&$17.40\end{array}</script></p>



<h4 id="exercise-3"><strong>Exercise 3</strong></h4>

<h4 id="part-a">Part a</h4>

<p>Let <script type="math/tex" id="MathJax-Element-163">P_i</script> represent Alice’s payoff in case <script type="math/tex" id="MathJax-Element-164">i</script>.</p>

<p><strong>Case 1</strong>: <script type="math/tex" id="MathJax-Element-165">b_1 = r, b_1 > b_2</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-166">P_1 = 500(r - b_2)</script></p>

<p><strong>Case 2</strong>: <script type="math/tex" id="MathJax-Element-167">b_1 = r, b_2 > b_1</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-168">P_2 ≤ 300r</script></p>

<p><strong>Case 3</strong>: <script type="math/tex" id="MathJax-Element-169">b_1 > r, b_1 > b_2</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-170">P_3 = 500(r - b_2)</script></p>

<p><strong>Case 4</strong>: <script type="math/tex" id="MathJax-Element-171">b_1 > r, b_1 > b_2 > r</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-172">P_4 = 500(r - b_2) < 0</script></p>

<p><strong>Case 5</strong>: <script type="math/tex" id="MathJax-Element-173">b_1 > r, b_2 > b_1</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-174">P_5 ≤ 300r</script></p>

<p><strong>Case 6</strong>: <script type="math/tex" id="MathJax-Element-175">b_1 < r, b_1 > b_2</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-176">P_6 = 500(r - b_2)</script></p>

<p><strong>Case 7</strong>: <script type="math/tex" id="MathJax-Element-177">b_1 < r, b_1 < b_2</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-178">P_7 ≤ 300r</script></p>



<h4 id="part-b">Part b</h4>

<p>Alice’s dominant strategy is to tell the truth, i.e., <script type="math/tex" id="MathJax-Element-209">b_1 = r</script>. This is because she will not know <script type="math/tex" id="MathJax-Element-210">b_2</script>, and if <script type="math/tex" id="MathJax-Element-211">b_1 ≠ r</script>, there is a chance that she will make a loss. If <script type="math/tex" id="MathJax-Element-212">b_1 = r</script>, there is no chance for Alice to make a loss.</p>



<h4 id="exercise-4"><strong>Exercise 4</strong></h4>

<p><em>a</em> <br>
Bidder 1 knows that in order to make a gain, she has to win both seats, but not only one seat as that payoff is negative. In order to do that, she must exceed Bidder 2’s valuation of a single seat (<script type="math/tex" id="MathJax-Element-235">\$10</script>) for both seats. However, since she cannot bid more than <script type="math/tex" id="MathJax-Element-236">\$15 / 2 = \$7.5</script> for both seats, it would be more profitable for her to abstain from bidding altogether than to try (Bidder 1 is a busy woman) or to win only one seat (as that would result in a negative payoff). </p>

<p>Bidder 1 would thus avoid the auction altogether and Bidder 2 would win both seats at the lowest possible price, the start price plus the minimum increment, which are both assumed to be <script type="math/tex" id="MathJax-Element-237">0</script>.</p>

<p>Bidder 2 wins both seats with a bid of <script type="math/tex" id="MathJax-Element-238">\$0</script>, pays nothing and gets a payoff of <script type="math/tex" id="MathJax-Element-239">\$12</script>.</p>

<p>If Bidder 1 is the kind of person who likes to see others lose money however, she would bid up to <script type="math/tex" id="MathJax-Element-240">\$2</script> for each seat. As Bidder 2 is not willing to bid more than that amount for a second seat, Bidder 1 avoids paying for an unwanted seat but still reduces the payoff for Bidder 2.</p>

<p>In this scenario, Bidder 2 still wins both seats, but pays <script type="math/tex" id="MathJax-Element-241">\$4</script> and receives a payoff of <script type="math/tex" id="MathJax-Element-242">\$8</script>.</p>

<p><em>b</em> <br>
In the first scenario, Bidder 1 knows she cannot win any seats and would rather avoid the possibility of having only one seat and getting a negative payoff. </p>

<p>However, if package bidding is used, since Bidder 1 has a higher valuation of both seats together than Bidder 2, Bidder 1 can win both seats by bidding higher than Bidder 1’s valuation of both seats.</p>

<p>In this scenario, Bidder 1 would win with a bid of <script type="math/tex" id="MathJax-Element-243">\$12</script> for both seats, pay <script type="math/tex" id="MathJax-Element-244">\$12</script> and get a payoff of <script type="math/tex" id="MathJax-Element-245">\$3</script>.</p>



<h4 id="exercise-5-vcg-auction"><strong>Exercise 5</strong>. VCG auction</h4>

<h5 id="find-the-prices-obtained-by-a-vcg-mechanism-for-the-bidders-and-items-below-the-numbers-above-the-edges-are-the-bidders-valuations">Find the prices obtained by a VCG mechanism for the bidders and items below (the numbers above the edges are the bidders’ valuations).</h5>

<p><script type="math/tex; mode=display" id="MathJax-Element-260">\begin{array}{|c|ccccc|}\hline
v_{ij}&j=1&j=2
\\\hline
i=1&10&2\\
i=2&3&8\\
i=3&5&6\\
i=4&7&9\\
\hline\end{array}</script></p>

<p>Maximise <script type="math/tex" id="MathJax-Element-261">\sum_{(ij)}v_{ij}</script></p>

<p>Best matching obtained is given by [(1,1),(4,2)], with a valuation of 10 + 9 = 19</p>

<p><script type="math/tex" id="MathJax-Element-262">V = v_{ij} - \hat V_{i \leftarrow j} = 19</script></p>

<p>Without bidder 1, the best matching is given by [(2,2),(4,1)], with a valuation of 8 + 7 = 15. This implies that </p>

<ul>
<li>bidder 1 has caused bidder 2 $8 worth of damage </li>
<li>bidder 1 has caused bidder 4 $-2 worth of damage</li>
</ul>

<p><script type="math/tex" id="MathJax-Element-263">\hat V_{1 \leftarrow 1} = 19 - 10 = 9</script></p>

<p><script type="math/tex" id="MathJax-Element-264">p_{11} = V_{no\ 1} - \hat V_{1 \leftarrow 1} = 15 - 9 = 6 = 8 + -2</script></p>

<p>As such, bidder 1 would have to pay $6.</p>

<p>Without bidder 4, the best matching is given by [(1,1),(2,2)], with a valuation of 10 + 8 = 18. This implies that </p>

<ul>
<li>bidder 4 has caused bidder 2 $8 worth of damage </li>
</ul>

<p><script type="math/tex" id="MathJax-Element-265">\hat V_{1 \leftarrow 1} = 19 - 9 = 10</script></p>

<p><script type="math/tex" id="MathJax-Element-266">p_{42} = V_{no\ 1} - \hat V_{1 \leftarrow 1} = 18 - 10 = 8 = 8</script></p>



<h4 id="exercise-6"><strong>Exercise 6</strong></h4>

<p><script type="math/tex; mode=display" id="MathJax-Element-365">H =
\begin{pmatrix}0&1&0&0\\0&0&1&0\\0&0&0&1\\1&0&0&0\end{pmatrix}</script></p>

<p>Performing 10 iterations: <br>
<script type="math/tex" id="MathJax-Element-366">\pi[0] = \begin{bmatrix}0.500&0.500&0.000&0.000\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-367">\pi[1] = \begin{bmatrix}0.000&0.500&0.500&0.000\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-368">\pi[2] = \begin{bmatrix}0.000&0.000&0.500&0.500\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-369">\pi[3] = \begin{bmatrix}0.500&0.000&0.000&0.500\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-370">\pi[4] = \begin{bmatrix}0.500&0.500&0.000&0.000\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-371">\pi[5] = \begin{bmatrix}0.000&0.500&0.500&0.000\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-372">\pi[6] = \begin{bmatrix}0.000&0.000&0.500&0.500\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-373">\pi[7] = \begin{bmatrix}0.500&0.000&0.000&0.500\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-374">\pi[8] = \begin{bmatrix}0.500&0.500&0.000&0.000\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-375">\pi[9] = \begin{bmatrix}0.000&0.500&0.500&0.000\end{bmatrix}^T</script> <br>
<script type="math/tex" id="MathJax-Element-376">\pi[10] = \begin{bmatrix}0.000&0.000&0.500&0.500\end{bmatrix}^T</script></p>

<p>Using this initialisation, there will never be convergence, even as <script type="math/tex" id="MathJax-Element-377">k</script> grows infinitely large.</p>

<p>Obvious solution is: <br>
<script type="math/tex" id="MathJax-Element-378">\pi^* = \begin{bmatrix}0.25&0.25&0.25&0.25\end{bmatrix}^T</script></p>



<h4 id="exercise-7"><strong>Exercise 7</strong></h4>

<pre class="prettyprint"><code class=" hljs lua">from __future__ import division
import numpy

N = <span class="hljs-number">5</span>
H_LIST = <span class="hljs-string">[[0,1,0,0,0],
    [1,0,0,0,0],
    [1/3,0,1/3,0,1/3],
    [0,0,1/2,0,1/2],
    [0,0,0,0,0]]</span>

ZERO_ROW = numpy.matrix([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]).T
THETAS = [<span class="hljs-number">0.1</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.85</span>]
THRESHOLD = <span class="hljs-number">1E-40</span>
START = <span class="hljs-number">1</span>/N * numpy.ones(<span class="hljs-number">5</span>)

H = numpy.matrix(H_LIST)
H_hat = H + (<span class="hljs-number">1</span>/N) * ZERO_ROW * numpy.ones(<span class="hljs-number">5</span>)

<span class="hljs-keyword">for</span> theta <span class="hljs-keyword">in</span> THETAS:
    <span class="hljs-built_in">print</span> <span class="hljs-string">"theta = "</span> + str(theta)
    G = theta * H_hat + (<span class="hljs-number">1</span> - theta) * (<span class="hljs-number">1</span>/N) * numpy.ones((<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))
    pi_old = START * G
    pi_new = pi_old * G
    counter = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> abs(numpy.sum(pi_old - pi_new)) &gt; THRESHOLD:
        pi_old = pi_new
        pi_new = pi_old * G
        counter += <span class="hljs-number">1</span>
    pi_list = pi_new[<span class="hljs-number">0</span>].tolist()[<span class="hljs-number">0</span>]
    <span class="hljs-built_in">print</span> <span class="hljs-string">"pi = "</span> + str([round(el, <span class="hljs-number">5</span>) <span class="hljs-keyword">for</span> el <span class="hljs-keyword">in</span> pi_list])
    sorted_pi_list = sorted(list(enumerate(pi_list)), key=lambda x: x[<span class="hljs-number">1</span>], reverse=True)
    <span class="hljs-built_in">print</span> <span class="hljs-string">"ranking = "</span> + str([el[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> el <span class="hljs-keyword">in</span> sorted_pi_list])
    <span class="hljs-built_in">print</span> <span class="hljs-string">"--------------------\n"</span>
</code></pre>

<p>Rounded to 3 decimal places,</p>

<p><script type="math/tex" id="MathJax-Element-388">\theta = 0.1:</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-389">\pi^* =  [0.211, 0.205, 0.2, 0.184, 0.2]\\
Ranking: 1, 2, 3, 5, 4
</script></p>

<p><script type="math/tex" id="MathJax-Element-390">\theta = 0.3:</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-391">\pi^* = [0.238, 0.223, 0.194, 0.152, 0.194]\\
Ranking: 1, 2, 3, 5, 4
</script></p>

<p><script type="math/tex" id="MathJax-Element-392">\theta = 0.5:</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-393">\pi^* = [0.275, 0.255, 0.176, 0.118, 0.176]\\
Ranking: 1, 2, 3, 5, 4
</script></p>

<p><script type="math/tex" id="MathJax-Element-394">\theta = 0.85:</script> <br>
<script type="math/tex; mode=display" id="MathJax-Element-395">
\pi^* = [0.394, 0.38, 0.09, 0.045, 0.09]\\
Ranking: 1, 2, 3, 5, 4
</script></p>

<p>The ranking remains the same, regardless of the choice of <script type="math/tex" id="MathJax-Element-396">\theta</script>.</p>



<h3 id="exercise-8-block-aggregation-in-pagerank-exercise-34-in-book"><strong>Exercise 8</strong>. Block aggregation in PageRank (exercise 3.4 in book)</h3>

<h5 id="set-θ-085-and-start-with-any-normalized-initial-vector-π0">Set θ = 0.85 and start with any normalized initial vector π[0].</h5>



<h5 id="a-compute-the-pagerank-vector-πa-πb-t-of-the-graph-in-figure-a-above-with-h-beginpmatrix101323endpmatrix">a) Compute the PageRank vector <script type="math/tex" id="MathJax-Element-397">[π_A^∗ π_B^∗ ]^T</script> of the graph in figure (a) above with <script type="math/tex; mode=display" id="MathJax-Element-398">H = \begin{pmatrix}1&0\\1/3&2/3\end{pmatrix}</script></h5>



<h5 id="note-the-uneven-splitting-of-link-weights-from-node-b-this-will-be-useful-later-in-the-problem">Note the uneven splitting of link weights from node B. This will be useful later in the problem.</h5>

<p>Since there is no dangling nodes, <script type="math/tex" id="MathJax-Element-399">\hat H = H</script></p>



<p><script type="math/tex; mode=display" id="MathJax-Element-400">G = \theta \hat H + (1-\theta) \frac{1}{N}11^T\\
=0.85\begin{pmatrix}1&0\\1/3&2/3\end{pmatrix} +0.15 \begin{pmatrix}1/2&1/2\\1/2&1/2\end{pmatrix}\\
=\begin{pmatrix}0.925&0.075\\0.35833&0.64166\end{pmatrix}</script></p>

<p>Let <script type="math/tex" id="MathJax-Element-401">\pi[0]^T = [1/2\ \ 1/2]^T</script></p>

<p>Since <script type="math/tex" id="MathJax-Element-402">\pi[i]^T = \pi[i-1]^T*G</script>, after iterating through the formula starting from i = 0, the pagerank vector converges to a value of <script type="math/tex; mode=display" id="MathJax-Element-403">\pi^*_{AB} = [\pi^*_A\ \pi^*_B]^T = \begin{pmatrix}0.82671998&0.17328002\end{pmatrix}^T</script></p>



<h5 id="b-compute-the-pagerank-vectors-π1-π2t-and-π3-π4-π5t-of-the-two-graphs-in-figure-b-above">b) Compute the PageRank vectors <script type="math/tex" id="MathJax-Element-404">[π_1^∗ π_2^∗]^T </script>and <script type="math/tex" id="MathJax-Element-405">[π_3^∗ π_4^∗ π_5^∗]^T</script> of the two graphs in figure (b) above.</h5>

<p>Graph 1</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-406">H_{12} = \begin{pmatrix}0&1\\1&0\end{pmatrix}</script></p>

<p>Since there is no dangling nodes, <script type="math/tex" id="MathJax-Element-407">\hat H_{12} = H_{12}</script></p>



<p><script type="math/tex; mode=display" id="MathJax-Element-408">G_{12} = \begin{pmatrix}0.925&0.075\\0.075&0.925\end{pmatrix}</script></p>



<p><script type="math/tex; mode=display" id="MathJax-Element-409">\pi^*_{12} = [\pi^*_1\ \pi^*_2]^T =\begin{pmatrix}0.5&  0.5\end{pmatrix}^T</script></p>

<p>Graph 2</p>



<p><script type="math/tex; mode=display" id="MathJax-Element-410">H_{345} = \begin{pmatrix}1/2&0&1/2\\1/2&0&1/2\\0&0&0\end{pmatrix}</script></p>



<p><script type="math/tex; mode=display" id="MathJax-Element-411">\hat H_{345} = \begin{pmatrix}1/2&0&1/2\\1/2&0&1/2\\1/3&1/3&1/3\end{pmatrix}</script></p>



<p><script type="math/tex; mode=display" id="MathJax-Element-412">G_{345} = \begin{pmatrix}0.475&0.05&0.475\\0.475&0.05&0.475\\1/3&1/3&1/3\end{pmatrix}</script></p>



<p><script type="math/tex; mode=display" id="MathJax-Element-413">\pi^*_{345} = [\pi^*_3\ \pi^*_4\ \pi^*_5]^T =\begin{pmatrix}0.41439815&0.1712037&0.41439815\end{pmatrix}^T</script></p>



<h5 id="c-if-we-divide-the-graph-in-exercise-7-into-two-blocks-as-shown-in-the-figure-below-we-can-approximate-π-in-the-previous-question-by">c) If we divide the graph in exercise 7 into two blocks as shown in the figure below, we can approximate <script type="math/tex" id="MathJax-Element-414">π^∗</script> in the previous question by</h5>

<p><script type="math/tex; mode=display" id="MathJax-Element-415">\hat π^∗ = [π_A^∗ · [π_1^∗ π_2^∗] π_B^∗ · [π_3^∗ π_4^∗ π_5^∗]]^T </script>.</p>



<h5 id="compute-this-vector-explain-the-advantage-in-terms-of-computational-load-of-using-this-approximation-instead-of-directly-computing-π">Compute this vector. Explain the advantage, in terms of computational load, of using this approximation instead of directly computing <script type="math/tex" id="MathJax-Element-416">π^∗</script>.</h5>

<p><script type="math/tex; mode=display" id="MathJax-Element-417">\hat π^∗ = [0.82671998 · [0.5\ \ 0.5]\ \ \ 0.17328002 · [0.41439815\ \ 0.1712037\ \ 0.41439815]]^T \\ 
=[0.41335999\ \ 0.41335999\ \ 0.07180691972\ \ 0.02966618056\ \ 0.07180691972]^T</script></p>

<p>The approximation is considerably less computationally expensive as our matrix operations involves matrices of a smaller size. As matrix multiplication of a m * n matrix and a n * p matrix is <script type="math/tex" id="MathJax-Element-418">O(mnp)</script>, or in this case <script type="math/tex" id="MathJax-Element-419">O(n^2)</script> since <script type="math/tex" id="MathJax-Element-420">m = 1</script>. As the size of matrix increases, the computational power required would increase quadratically.</p>

<blockquote>
  <p>Written with <a href="https://stackedit.io/">StackEdit</a>.</p>
</blockquote></div></body>
</html>